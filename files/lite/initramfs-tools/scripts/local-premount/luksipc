#!/bin/sh
# resize partition table script
# install in initramfs-tools/scripts/local-premount

PREREQ="resize-parttbl"
prereqs()
{
     echo "$PREREQ"
}

case $1 in
prereqs)
     prereqs
     exit 0
     ;;
esac

. /scripts/functions

# step 1 - finding a filesystem labeled boot or IMD
boot_or_imd_parts () {
  # list partitions labeled IMD or boot - return an error if we find more than one
  local wktmp line bootct=0 imdct=0
  wktmp=$(mktemp)
  blkid > "${wktmp}"
  while read -r line ; do
    case $line in
      *'LABEL="IMD"'*)  echo "${line%: *}:imd"  ; imdct=$(expr ${imdct} + 1)  ;;
      *'LABEL="boot"'*) echo "${line%: *}:boot" ; bootct=$(expr ${bootct} + 1) ;;
    esac
  done < "${wktmp}"
  rm "${wktmp}"
  [[ "${imdct}"  -gt 2 ]] && return 1
  [[ "${bootct}" -gt 2 ]] && return 1
  return 0
}

get_driveletter () {
  # return a drive letter match for mtools.conf
  local MTOOLSRC="${MTOOLSRC:-/etc/mtools.conf}"
  local line src=$1 res
  while read -r line ; do
    case $line in
      *' file="'"${src}"'"') res="${line:6:1}" ;;
    esac
  done < "${MTOOLSRC}"
  [[ "${res}" ]] || return 1
  echo "${res}"
}

# bail if we're resuming, ok?
if [ -n "${resume?}" ] || [ -e /sys/power/resume ]; then
        exit 0
fi

# deps
command -v cryptsetup >/dev/null || exit 0
command -v cryptsetup-reencrypt >/dev/null || exit 0
command -v blkid >/dev/null || exit 0
command -v awk >/dev/null || exit 0
command -v mcopy >/dev/null || exit 0
command -v mktemp >/dev/null || exit 0

# find partitions belonging to the root block device and extend them.
[ "${ROOT}" = "/dev/mapper/luksroot" ] || exit 0

for arg in $(cat /proc/cmdline) ; do
  case "${arg}" in
    luksipc=*)
      srcdev="${arg#luksipc=}"
    ;;
  esac
done

[ "${srcdev}" ] || exit 0

case "${srcdev}" in
  /*)
    srcdev="${ROOT}"
   ;;
  *=*)
    lsbk=$(echo "${srcdev}" | awk -F= '{ print $1 }')
    lsbv=$(echo "${srcdev}" | awk -F= '{ gsub(/"/, "", $2) ; print $2 }')
    srcdev=$(blkid | awk -F: '$2 ~ "'"${lsbk}"'=\"'"${lsbv}"'\"" { print $1 }')
   ;;
esac

dataland=''
partlist=$(mktemp)
boot_or_imd_parts > "${partlist}"
grep -q ':imd$' "${partlist}" && {
  dataland=$(grep ':imd$' "${partlist}")
}
grep -q ':boot$' "${partlist}" && {
  dataland=$(grep ':boot$' "${partlist}")
}
rm "${partlist}"

[ "${dataland}" ] || exit 0
dataland="${dataland%:*}"

mkdir /run/cryptsetup

log_begin_msg "luksipc: examining ${srcdev}"

for arg in $(blkid "${srcdev}") ; do
  case "${arg}" in
    'TYPE="ext4"')
      log_begin_msg "generating keyfile..."
        dd if=/dev/random of=/run/luksipc.key bs=1 count=32
	mcopy /run/luksipc.key $(get_driveletter "${dataland}"):luksipc.key
      log_end_msg
      log_begin_msg "converting ${srcdev} to LUKS..."
        cryptsetup-reencrypt --reduce-device-size=16M --new "${srcdev}" --key-file /run/luksipc.key
      log_end_msg
    ;;
    'TYPE="crypto_LUKS"')
      mcopy $(get_driveletter "${dataland}"):luksipc.key /run
    ;;
  esac
done

cryptsetup luksOpen --key-file /run/luksipc.key "${srcdev}" luksroot

log_end_msg

check_imd_file () {
  # walk partition list and check for MDDATA.XML - priority is IMD, BOOT
  # or we try boot:IMD/MDDATA.XML
  local table drive
  table=$(boot_or_imd_parts) || return 1
  local row bootpart imdpart imdfile=''
  for row in ${table} ; do
    case $row in
      *:boot) bootpart="${row%:*}" ;;
      *:imd)  imdpart="${row%:*}"  ;;
    esac
  done

  [[ "${imdpart}" ]] && {
    drive="$(get_driveletter "${imdpart}")"
    mdir "${drive}:MDDATA.XML" > /dev/null && imdfile="${drive}:MDDATA.XML"
  }

  [[ "${imdfile}" ]] || {
    [[ "${bootpart}" ]] && {
      drive="$(get_driveletter "${bootpart}")"
      mdir "${drive}:IMD/MDDATA.XML" > /dev/null && imdfile="${drive}:IMD/MDDATA.XML"
    }
  }
  [[ "${imdfile}" ]] && {
    echo "${imdfile}"
    return 0
  }
  return 1
}

copy_imd_file () {
  # copy an imd file to /run/MDDATA.XML
  local fsrc
  fsrc="$(check_imd_file)"
  [[ "${fsrc}" ]] || return 1
  mcopy "${fsrc}" /run/MDDATA.XML
}
